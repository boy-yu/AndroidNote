# 序列化与反序列化

## 定义

- 序列化:把**内存中的对象**（如自定义 `User`、`Order` 类）转换成**字节流 / 可传输格式**，使其能跨组件、跨进程传输，或持久化到文件 / SP 中
- 反序列化:把**字节流 / 存储的格式**还原成内存中的对象，恢复对象的原始数据和状态。

Android 中序列化的核心目的：解决「不同组件（Activity/Fragment）、不同进程间传递自定义对象」「对象持久化存储」的问题（比如 Intent 传自定义对象、AIDL 跨进程通信、保存用户信息到 SP）。

## 两种核心序列化方式

Android 支持两种主流序列化方案：`Serializable`（Java 原生）和 `Parcelable`（Android 专属），两者设计目标、性能、适用场景差异极大：

| 维度     | Serializable（Java 原生）                  | Parcelable（Android 专属）                      |
| -------- | ------------------------------------------ | ----------------------------------------------- |
| 底层实现 | 基于 Java 反射机制，自动读写对象字段       | 手动实现内存块读写，直接操作原生数据（无反射）  |
| 性能     | 低（反射产生大量临时对象，冗余数据多）     | 高（直接操作内存，效率是 Serializable 10 倍 +） |
| 代码量   | 极少（仅标记接口 + 可选 serialVersionUID） | 稍多（需手动实现序列化 / 反序列化方法）         |
| 核心优势 | 简单、支持持久化（存文件 / SP）            | 高效、适配 Android 组件 / IPC 场景              |
| 核心劣势 | 性能差、不适合高频传输                     | 不支持直接持久化（Parcel 是内存数据）           |
| 版本兼容 | 依赖 `serialVersionUID` 保证兼容           | 需手动保证字段读写顺序一致                      |

### 两种方式的核心原理 & 适用场景

#### Serializable（简单但低效）

**核心原理**

`Serializable` 是「标记接口」（无任何抽象方法），仅告诉 JVM：这个类的对象可以被序列化。

- 序列化：通过 `ObjectOutputStream` 将对象的字段（非 `transient` 修饰）转换成字节流；
- 反序列化：通过 `ObjectInputStream` 读取字节流，反射重建对象（**反序列化时不会执行构造函数**）。

**关键注意点**

- 必须加 `serialVersionUID`：手动指定版本号（如 `private static final long serialVersionUID = 1L;`），否则 JVM 会根据类结构自动生成 —— 类结构变化（增删字段）后，UID 改变会导致反序列化直接抛 `InvalidClassException`；
- `transient` 关键字：标记的字段不会被序列化（比如临时数据、敏感信息如密码）；
- 成员变量需可序列化：若对象包含其他自定义类成员，该成员类也必须实现 `Serializable`。

**适用场景**

- 对象持久化：保存到本地文件、SharedPreferences（比如把用户信息序列化后存 SP）；
- 低频率、小数据量传输：比如偶尔通过 Intent 传简单对象（非高频场景）；
- 跨平台 / 网络传输：比如将对象转字节流通过网络发送（替代 JSON 的兜底方案）。

####  Parcelable（高效，Android 首选）

**核心原理**

`Parcelable` 是 Android 专为「跨进程通信（IPC）」设计的序列化方案，核心是**手动控制对象字段的读写**，直接操作内存块（Parcel 是 Android 封装的内存容器），避免反射开销。

- 序列化：重写 `writeToParcel()` 方法，手动将字段写入 `Parcel`；
- 反序列化：通过 `CREATOR` 静态常量，重写 `createFromParcel()` 方法，从 `Parcel` 中按顺序读取字段，重建对象。

**关键注意点**

- 字段读写顺序必须一致：`writeToParcel()` 写字段的顺序，必须和 `createFromParcel()` 读的顺序完全相同（否则数据错乱）；
- 支持的字段类型：基本类型（int/long 等）、String、List/Map（需是 Parcelable/Serializable 类型）、其他 Parcelable 对象（嵌套序列化需调用该对象的 `writeToParcel()`）；
- 大小限制：Parcel 有内存上限（约 1MB），传输超大对象（如 Bitmap、大列表）会抛 `TransactionTooLargeException`。

**适用场景**

- 组件间传参：Activity/Fragment 之间通过 Intent/Bundle 传自定义对象（比如从列表页传 `Goods` 对象到详情页）；
- 跨进程通信：AIDL、Messenger、ContentProvider 等 IPC 场景（比如 App 和后台 Service 传对象）；
- 高频操作：RecyclerView 适配器传复杂对象（追求性能，避免反射开销）。

## 进阶补充

1. **简化 Parcelable 代码**：
   Android Studio 可通过插件（如「Parcelable Code Generator」）或 Kotlin 的 `@Parcelize` 注解（需开启实验性特性），自动生成 Parcelable 相关代码，无需手动写；
2. **混合使用两种方式**：
   同一个类可同时实现 `Serializable` 和 `Parcelable`—— 持久化用 `Serializable`，组件传参用 `Parcelable`；
3. **替代方案：JSON 序列化**：
   比如 Gson/Jackson 将对象转 JSON 字符串（文本格式），虽不是原生序列化，但跨平台、易调试，性能介于两者之间，适合网络传输、跨端交互；
4. **避坑点**：
   - 不要序列化大对象（如 Bitmap）：优先传路径 / ID，而非直接序列化对象；
   - 反序列化时的空值处理：字段缺失时，Serializable 会赋默认值（如 int=0、String=null），Parcelable 需手动判空；
   - 内存泄漏：序列化对象若持有 Activity 引用，会导致组件无法回收（建议序列化数据类，而非持有上下文的类）。

# 内存管理与数据传递规则

「**内存视角下的数据操作规则**」—— 前者管 “数据在函数间传递时的内存映射”，后者管 “数据复制时的内存分配”，共同构成了 “如何安全操作对象（避免意外修改、内存泄漏）” 的基础。

**所有对象都存储在 JVM 堆内存中，变量（包括函数参数）仅存储 “指向堆对象的内存地址（引用）”；值传递 / 引用传递决定 “参数变量如何传递这个地址”，深拷贝 / 浅拷贝决定 “是否新建堆内存来存储对象的完整数据”**。

Java/Kotlin 仅支持「值传递」，传递参数时分为两种情况：

- 基本类型（int/Int、long/Long）：传递 “栈内存中值的副本”→ 函数内修改副本不影响原变量（无拷贝问题，因为无堆对象）；
- 对象类型（自定义类、List、Map）：传递 “堆对象地址的副本”→ 函数内的参数变量和原变量指向**同一个堆对象**（这是浅拷贝的 “天然状态”）。

正因为对象的 “值传递” 本质是 “地址副本传递”，导致函数内修改对象属性会直接影响原对象（堆内存共享），而浅拷贝 / 深拷贝是解决 “是否要打破这种共享” 的手段：

- 浅拷贝：仅复制 “对象地址”（或仅复制对象本身，内部引用成员仍指向原堆地址）→ 新对象与原对象仍共享堆内存中的引用类型成员（比如 List、子对象），等价于 “值传递的天然状态”；
- 深拷贝：不仅复制对象本身，还为所有引用类型成员**新建堆内存**→ 新对象与原对象完全隔离，即使在函数内修改深拷贝后的对象，也不会影响原对象。

实践代码:

```kotlin
// 场景：修改用户的爱好列表/姓名，但不想影响原对象
// 核心修改：name 从 val 改为 var（可重新赋值）
data class User(var name: String, val hobbies: MutableList<String>) {
    // 自定义深拷贝方法（核心：为hobbies新建堆内存，name因是String直接赋值即可）
    fun deepCopy() = User(name, hobbies.toMutableList())
}

// 1. 无拷贝（值传递的天然状态 = 浅拷贝级共享）
fun modifyHobbies1(user: User) {
    user.hobbies.add("游泳") // 修改共享的List → 原对象hobbies变
    user.name = "张三-修改1"  // 修改name（重新赋值）→ 原对象name变（因为是同一User对象）
}

// 2. 浅拷贝（仅复制User对象，hobbies仍共享堆地址；name是新值但hobbies共享）
fun modifyHobbies2(user: User) {
    val copyUser = user.copy() // data class默认浅拷贝：name复制值，hobbies复制引用
    copyUser.hobbies.add("游泳") // 仍修改原堆中的List → 原对象hobbies变
    copyUser.name = "张三-修改2"  // 仅修改拷贝对象的name → 原对象name不变（name是基本类型级复制）
}

// 3. 深拷贝（复制User+hobbies的堆内存，完全隔离）
fun modifyHobbies3(user: User) {
    val copyUser = user.deepCopy() // 深拷贝：name赋值、hobbies新建List
    copyUser.hobbies.add("游泳") // 仅修改新堆中的List → 原对象hobbies不变
    copyUser.name = "张三-修改3"  // 仅修改拷贝对象的name → 原对象name不变
}

fun main() {
    val originalUser = User("张三", mutableListOf("篮球"))

    // 测试1：无拷贝（直接修改原对象）
    modifyHobbies1(originalUser)
    println("测试1 - name：${originalUser.name}，hobbies：${originalUser.hobbies}") 
    // 输出：name：张三-修改1，hobbies：[篮球, 游泳]（原对象全变）

    // 重置原对象
    originalUser.hobbies.clear()
    originalUser.name = "张三"

    // 测试2：浅拷贝（hobbies共享，name独立）
    modifyHobbies2(originalUser)
    println("测试2 - name：${originalUser.name}，hobbies：${originalUser.hobbies}") 
    // 输出：name：张三，hobbies：[篮球, 游泳]（仅hobbies变）

    // 重置原对象
    originalUser.hobbies.clear()
    originalUser.name = "张三"

    // 测试3：深拷贝（完全隔离）
    modifyHobbies3(originalUser)
    println("测试3 - name：${originalUser.name}，hobbies：${originalUser.hobbies}") 
    // 输出：name：张三，hobbies：[篮球]（原对象完全不变）
}
```

- 函数调用时，`originalUser` 以「值传递」方式传递 “**堆地址的副本**” 给函数参数；
- 若仅用默认的浅拷贝（或无拷贝），地址副本指向原堆对象，修改**会影响**原对象；
- 若用深拷贝，会新建堆内存存储完整对象，打破地址共享，实现修改隔离。

核心总结（串联后的逻辑闭环）

| 知识点            | 核心作用                          | 底层关联（内存视角）                  | 开发中的协同关系                                             |
| ----------------- | --------------------------------- | ------------------------------------- | ------------------------------------------------------------ |
| 值传递 / 引用传递 | 定义 “函数参数如何映射到内存地址” | 决定参数是 “地址副本” 还是 “地址本身” | 是前提：Java/Kotlin 仅值传递，导致对象参数天然共享堆地址，这是浅拷贝问题的根源； |
| 深拷贝 / 浅拷贝   | 定义 “对象复制时如何分配新内存”   | 决定是否为引用成员新建堆内存          | 是解决方案：浅拷贝延续 “地址共享”，深拷贝打破共享，解决值传递中 “意外修改原对象” 的问题； |

